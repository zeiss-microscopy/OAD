# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: zen_api/acquisition/v1beta/experiment_descriptor.proto, zen_api/acquisition/v1beta/experiment_service.proto, zen_api/acquisition/v1beta/experiment_status.proto, zen_api/acquisition/v1beta/experiment_streaming_service.proto, zen_api/acquisition/v1beta/frame_data.proto, zen_api/acquisition/v1beta/frame_pixel_data.proto, zen_api/acquisition/v1beta/frame_position.proto, zen_api/acquisition/v1beta/frame_stage_position.proto, zen_api/acquisition/v1beta/pixel_type.proto, zen_api/acquisition/v1beta/scaling.proto
# plugin: python-betterproto
# This file has been @generated

from dataclasses import dataclass
from datetime import timedelta
from typing import (
    TYPE_CHECKING,
    AsyncIterator,
    Dict,
    List,
    Optional,
)

import betterproto
import betterproto.lib.google.protobuf as betterproto_lib_google_protobuf
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase

from ...common import v1 as __common_v1__


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


class PixelType(betterproto.Enum):
    """Pixel type of image data."""

    UNSPECIFIED = 0
    """Default value if status is not specified."""

    GRAY8 = 1
    """8 bit unsigned."""

    GRAY16 = 2
    """16 bit unsigned."""

    BGR24 = 4
    """8 bit triples, representing the color channels Blue, Green and Red."""

    BGR48 = 5
    """16 bit triples, representing the color channels Blue, Green and Red."""


@dataclass(eq=False, repr=False)
class ExperimentDescriptor(betterproto.Message):
    """Descriptors for experiment."""

    name: str = betterproto.string_field(1)
    """Experiment name."""


@dataclass(eq=False, repr=False)
class ExperimentStatus(betterproto.Message):
    """
    Status of an experiment.
     The index properties are 0-based.
     If a value is 0 or -1 it means the value is not initialized or
     the running experiment does not have the corresponding dimension.
     In case of indices, 0 value can also refer to the first element.
    """

    tiles_index: int = betterproto.int32_field(1)
    """
    The current or already acquired (depending of the dimension order) tiles position index
     of the currently acquired scene.
    """

    tiles_count: int = betterproto.int32_field(2)
    """The tiles count of the currently acquired scene."""

    cumulated_tiles_count: int = betterproto.int32_field(3)
    """The total tiles count of all scenes."""

    scenes_index: int = betterproto.int32_field(4)
    """
    The current or already acquired (depending of the dimension order) scene index (= tile region/position index).
    """

    scenes_count: int = betterproto.int32_field(5)
    """The total scene count (= tile region/position count)."""

    time_points_index: int = betterproto.int32_field(6)
    """
    The current or already acquired (depending of the dimension order) time point index in time series.
    """

    time_points_count: int = betterproto.int32_field(7)
    """The number of time points in time series."""

    zstack_slices_index: int = betterproto.int32_field(8)
    """
    The current or already acquired (depending of the dimension order) z-stack slice index.
    """

    zstack_slices_count: int = betterproto.int32_field(9)
    """The total count of z-stack slices."""

    channels_index: int = betterproto.int32_field(10)
    """
    The current or already acquired (depending of the dimension order) channel index.
    """

    channels_count: int = betterproto.int32_field(11)
    """The total channel count."""

    images_acquired_index: int = betterproto.int32_field(12)
    """
    The number of acquired images over all dimensions (channels, time series, z-stack, cumulated tiles).
    """

    images_count: int = betterproto.int32_field(13)
    """
    The images count over all dimensions (channels, time series, z-stack, cumulated tiles).
     This value is relevant only for acquisition where end is determined (standard experiment and Snap),
     therefore it is not relevant for Continuous and Live.
    """

    is_experiment_running: bool = betterproto.bool_field(14)
    """A value indicating whether the experiment is currently running."""

    is_acquisition_running: bool = betterproto.bool_field(15)
    """A value indicating whether an acquisition is currently running."""

    total_elapsed_time: timedelta = betterproto.message_field(16)
    """
    The total time that elapsed since the start of the running experiment.
    """


@dataclass(eq=False, repr=False)
class ExperimentServiceCloneRequest(betterproto.Message):
    """The ExperimentServiceCloneRequest class."""

    experiment_id: str = betterproto.string_field(1)
    """Id of the experiment to be cloned."""


@dataclass(eq=False, repr=False)
class ExperimentServiceCloneResponse(betterproto.Message):
    """Response object of the method for cloning an experiment."""

    experiment_id: str = betterproto.string_field(1)
    """The experiment id which is used to reference the cloned experiment."""


@dataclass(eq=False, repr=False)
class ExperimentServiceDeleteRequest(betterproto.Message):
    """The ExperimentServiceDeleteRequest class."""

    experiment_name: str = betterproto.string_field(1)
    """Name of the experiment to be deleted."""


@dataclass(eq=False, repr=False)
class ExperimentServiceDeleteResponse(betterproto.Message):
    """The ExperimentServiceDeleteResponse class."""

    pass


@dataclass(eq=False, repr=False)
class ExperimentServiceExportRequest(betterproto.Message):
    """The ExperimentServiceExportRequest class."""

    experiment_id: str = betterproto.string_field(1)
    """Experiment id."""


@dataclass(eq=False, repr=False)
class ExperimentServiceExportResponse(betterproto.Message):
    """Response object of the method for exporting an experiment."""

    xml: str = betterproto.string_field(1)
    """Xml string of experiment."""


@dataclass(eq=False, repr=False)
class ExperimentServiceGetAvailableExperimentsRequest(betterproto.Message):
    """The ExperimentServiceGetAvailableExperimentsRequest class."""

    pass


@dataclass(eq=False, repr=False)
class ExperimentServiceGetAvailableExperimentsResponse(betterproto.Message):
    """Response object of available experiments."""

    experiments: List["ExperimentDescriptor"] = betterproto.message_field(1)
    """List of available experiments."""


@dataclass(eq=False, repr=False)
class ExperimentServiceGetImageOutputPathRequest(betterproto.Message):
    """The ExperimentServiceGetImageOutputPathRequest class."""

    pass


@dataclass(eq=False, repr=False)
class ExperimentServiceGetImageOutputPathResponse(betterproto.Message):
    """Response object of the method for getting the image output path."""

    image_output_path: str = betterproto.string_field(1)
    """The image output path."""


@dataclass(eq=False, repr=False)
class ExperimentServiceGetStatusRequest(betterproto.Message):
    """The ExperimentServiceGetStatusRequest class."""

    experiment_id: str = betterproto.string_field(1)
    """
    ID of an experiment for which status is requested.
     If ID is provided, the status can be retrieved for both active and finished experiments.
     If ID is not provided, status of one of the active experiments is returned.
     If ID is not provided and there are no active experiments, an exception is thrown.
    """


@dataclass(eq=False, repr=False)
class ExperimentServiceGetStatusResponse(betterproto.Message):
    """Response object representing the status of an experiment."""

    status: "ExperimentStatus" = betterproto.message_field(1)
    """The experiment status."""


@dataclass(eq=False, repr=False)
class ExperimentServiceImportRequest(betterproto.Message):
    """The ExperimentServiceImportRequest class."""

    xml_string: str = betterproto.string_field(1)
    """Xml string of the experiment."""


@dataclass(eq=False, repr=False)
class ExperimentServiceImportResponse(betterproto.Message):
    """Response object of the method for importing an experiment."""

    experiment_id: str = betterproto.string_field(1)
    """
    The experiment id which is used to reference the imported experiment.
    """


@dataclass(eq=False, repr=False)
class ExperimentServiceLoadRequest(betterproto.Message):
    """The ExperimentServiceLoadRequest class."""

    experiment_name: str = betterproto.string_field(1)
    """Name of the experiment."""


@dataclass(eq=False, repr=False)
class ExperimentServiceLoadResponse(betterproto.Message):
    """Response object of the method for loading an experiment."""

    experiment_id: str = betterproto.string_field(1)
    """The experiment id which is used to reference the loaded experiment."""


@dataclass(eq=False, repr=False)
class ExperimentServiceRegisterOnStatusChangedRequest(betterproto.Message):
    """The ExperimentServiceRegisterOnStatusChangedRequest class."""

    experiment_id: str = betterproto.string_field(1)
    """
    ID of an active experiment for which status is monitored.
     If ID is not provided, status of one of the active experiments is monitored.
    """


@dataclass(eq=False, repr=False)
class ExperimentServiceRegisterOnStatusChangedResponse(betterproto.Message):
    """
    Response object representing the status of an experiment.
     It contains full set of status information, which can consist a single or multiple new states.
    """

    status: "ExperimentStatus" = betterproto.message_field(1)
    """The experiment status."""


@dataclass(eq=False, repr=False)
class ExperimentServiceRunExperimentRequest(betterproto.Message):
    """The ExperimentServiceRunExperimentRequest class."""

    experiment_id: str = betterproto.string_field(1)
    """Experiment id."""

    output_name: str = betterproto.string_field(2)
    """
    Optional name of the experiment's output. If a null or an empty name is provided, the
     output name will be created automatically, otherwise the output name must be in a format
     of a file name without a file extension.
    """


@dataclass(eq=False, repr=False)
class ExperimentServiceRunExperimentResponse(betterproto.Message):
    """Information about execution of an experiment."""

    output_name: str = betterproto.string_field(1)
    """
    The name of the experiment's output (in a format of a file name without a
     file extension).
    """


@dataclass(eq=False, repr=False)
class ExperimentServiceRunSnapRequest(betterproto.Message):
    """The ExperimentServiceRunSnapRequest class."""

    experiment_id: str = betterproto.string_field(1)
    """Experiment id."""

    output_name: str = betterproto.string_field(2)
    """
    Optional name of the experiment's output. If a null or an empty name is provided, the
     output name will be created automatically, otherwise the output name must be in a format
     of a file name without a file extension.
    """


@dataclass(eq=False, repr=False)
class ExperimentServiceRunSnapResponse(betterproto.Message):
    """Information about execution of a snap experiment."""

    output_name: str = betterproto.string_field(1)
    """
    The name of the snap's output (in a format of a file name without a file
     extension).
    """


@dataclass(eq=False, repr=False)
class ExperimentServiceSaveRequest(betterproto.Message):
    """The ExperimentServiceSaveRequest class."""

    experiment_id: str = betterproto.string_field(1)
    """Experiment id."""

    experiment_name: str = betterproto.string_field(2)
    """Name to be used when saving the experiment."""

    allow_override: bool = betterproto.bool_field(3)
    """Allow override of already existing experiment with the same name."""


@dataclass(eq=False, repr=False)
class ExperimentServiceSaveResponse(betterproto.Message):
    """The ExperimentServiceSaveResponse class."""

    pass


@dataclass(eq=False, repr=False)
class ExperimentServiceStartContinuousRequest(betterproto.Message):
    """The ExperimentServiceStartContinuousRequest class."""

    experiment_id: str = betterproto.string_field(1)
    """Experiment id."""


@dataclass(eq=False, repr=False)
class ExperimentServiceStartExperimentRequest(betterproto.Message):
    """The ExperimentServiceStartExperimentRequest class."""

    experiment_id: str = betterproto.string_field(1)
    """Experiment id."""

    output_name: str = betterproto.string_field(2)
    """
    Optional name of the experiment's output. If a null or an empty name is provided, the
     output name will be created automatically, otherwise the output name must be in a format
     of a file name without a file extension.
    """


@dataclass(eq=False, repr=False)
class ExperimentServiceStartExperimentResponse(betterproto.Message):
    """Information about execution of an experiment."""

    output_name: str = betterproto.string_field(1)
    """
    The name of the experiment's output (in a format of a file name without a
     file extension).
    """


@dataclass(eq=False, repr=False)
class ExperimentServiceStartLiveRequest(betterproto.Message):
    """The ExperimentServiceStartLiveRequest class."""

    experiment_id: str = betterproto.string_field(1)
    """Experiment id."""

    track_index: Optional[int] = betterproto.message_field(
        2, wraps=betterproto.TYPE_INT32
    )
    """
    Optional track index. When index is not provided the first selected or activated track
     (in that order) will be used, but when the index is provided the track with than index
     will be selected. The track index starts with "0".
    """


@dataclass(eq=False, repr=False)
class ExperimentServiceStartSnapRequest(betterproto.Message):
    """The ExperimentServiceStartSnapRequest class."""

    experiment_id: str = betterproto.string_field(1)
    """Experiment id."""

    output_name: str = betterproto.string_field(2)
    """
    Optional name of the experiment's output. If a null or an empty name is provided, the
     output name will be created automatically, otherwise the output name must be in a format
     of a file name without a file extension.
    """


@dataclass(eq=False, repr=False)
class ExperimentServiceStartSnapResponse(betterproto.Message):
    """Information about execution of a snap experiment."""

    output_name: str = betterproto.string_field(1)
    """
    The name of the snap's output (in a format of a file name without a file
     extension).
    """


@dataclass(eq=False, repr=False)
class ExperimentServiceStopRequest(betterproto.Message):
    """The ExperimentServiceStopRequest class."""

    experiment_id: str = betterproto.string_field(1)
    """
    ID of an experiment to stop or an empty GUID to stop one of the active experiments.
    """


@dataclass(eq=False, repr=False)
class ExperimentServiceStopResponse(betterproto.Message):
    """Information about execution of an experiment."""

    experiment_id: str = betterproto.string_field(1)
    """
    The ID of the experiment which is used to reference the stopped experiment.
    """


@dataclass(eq=False, repr=False)
class FramePixelData(betterproto.Message):
    """
    A simple container for the frame pixel data. This can contain either the pixels of a full
     frame or only a part of it (e.g., a line or a rectangle in case of partial acquisition when
     working with EM and LSM).
    """

    start_position: "__common_v1__.IntPoint" = betterproto.message_field(1)
    """
    The start position (in pixels) of the pixel data in the frame.
     Together with the size property, this represents the rectangle where the pixels are
     located inside the full frame. For ordinary acquisition this will be the top left corner
     of the frame, but for partial acquisition this can be any position inside the full frame
     relative to the top left corner.
    """

    size: "__common_v1__.IntSize" = betterproto.message_field(2)
    """
    Size (in pixels) of the pixel data.
     Together with the start position property, this represents the rectangle where the
     pixels are located inside the full frame. For ordinary acquisition this will be the full
     frame size, but for partial acquisition this can be just one part of the full frame.
    """

    pixel_type: "PixelType" = betterproto.enum_field(3)
    """The pixel type of the frame."""

    raw_data: bytes = betterproto.bytes_field(4)
    """
    The raw pixel data.
     The value of individual pixels is contained in this container. The pixel values need to
     be extracted from the raw byte data. The number of bits needed to extract a single pixel
     from the raw byte data and the format it is stored in is determined by the pixel type
     property.
    """


@dataclass(eq=False, repr=False)
class FramePosition(betterproto.Message):
    """Defines the position of the frame in multiple dimensions."""

    x: int = betterproto.int32_field(1)
    """The pixel index in X direction of the top left corner of the frame."""

    y: int = betterproto.int32_field(2)
    """The pixel index in Y direction of the top left corner of the frame."""

    z: int = betterproto.int32_field(3)
    """The Z slice index of the of the frame."""

    t: int = betterproto.int32_field(4)
    """
    The time point of the frame in a sequentially acquired series of data.
     Note that this doesn't represents the exact time of acquisition but only the sequence of
     the acquired image.
    """

    s: int = betterproto.int32_field(5)
    """The scene index."""

    m: int = betterproto.int32_field(6)
    """The mosaic tile index."""

    c: int = betterproto.int32_field(7)
    """The channel index in a multi-channel data set."""

    h: int = betterproto.int32_field(8)
    """The raw data index."""


@dataclass(eq=False, repr=False)
class FrameStagePosition(betterproto.Message):
    """Defines the stage position of the acquired frame."""

    x: Optional[float] = betterproto.message_field(1, wraps=betterproto.TYPE_DOUBLE)
    """The stage position in X direction (unit: m)."""

    y: Optional[float] = betterproto.message_field(2, wraps=betterproto.TYPE_DOUBLE)
    """The stage position in Y direction (unit: m)."""

    z: Optional[float] = betterproto.message_field(3, wraps=betterproto.TYPE_DOUBLE)
    """The stage position in Z direction (unit: m)."""


@dataclass(eq=False, repr=False)
class Scaling(betterproto.Message):
    """Defines the scaling of the acquired frame."""

    x: float = betterproto.double_field(1)
    """The scaling in X dimension (unit: m/pixel)."""

    y: float = betterproto.double_field(2)
    """The scaling in Y dimension (unit: m/pixel)."""


@dataclass(eq=False, repr=False)
class FrameData(betterproto.Message):
    """
    A simple container for the frame data. This can contain either a full frame or only a part
     of it (e.g., in case of partial acquisition when working with EM and LSM).
    """

    experiment_id: str = betterproto.string_field(1)
    """The ID of the experiment."""

    frame_number: int = betterproto.int32_field(2)
    """
    The frame sequence number.
     One frame can represent either a single image taken by the camera or one full scan in
     case of partial acquisition. One frame can also contain multiple channels if they are
     acquired in the same image or scan.
    """

    frame_position: "FramePosition" = betterproto.message_field(3)
    """The position of the full frame."""

    frame_size: "__common_v1__.IntSize" = betterproto.message_field(4)
    """The size of the full frame (in pixels)."""

    frame_stage_position: "FrameStagePosition" = betterproto.message_field(5)
    """The stage position of the acquired full frame."""

    scaling: "Scaling" = betterproto.message_field(6)
    """The scaling of the frame."""

    pixel_data: "FramePixelData" = betterproto.message_field(7)
    """
    The pixel data of the frame.
     This can contain either the pixels of a full frame or only a part of it (e.g., a line or
     a rectangle in case of partial acquisition when working with EM and LSM).
    """


@dataclass(eq=False, repr=False)
class ExperimentStreamingServiceMonitorAllExperimentsRequest(betterproto.Message):
    """The ExperimentStreamingServiceMonitorAllExperimentsRequest class."""

    channel_index: Optional[int] = betterproto.message_field(
        1, wraps=betterproto.TYPE_INT32
    )
    """
    Optional parameter for filtering by specific channel. If the channel index is provided,
     then only that channel will be monitored, but if the channel index is not provided, then
     all channels will be monitored.
    """

    enable_raw_data: bool = betterproto.bool_field(2)
    """
    Value indicating whether the streamed frame data contains raw frames as received from
     the acquisition (when set), which can be either full or partial frames (e.g., in general
     LM cameras produce full frames and LSM and EM detectors produce partial frames/lines).
     Otherwise (when not set) the streamed frame data contains only full frames, which means
     that in the case of partial frames/lines, they would be assembled into full frames.
    """


@dataclass(eq=False, repr=False)
class ExperimentStreamingServiceMonitorAllExperimentsResponse(betterproto.Message):
    """Response object of the method for monitoring all experiments."""

    frame_data: "FrameData" = betterproto.message_field(1)
    """The experiment's frame data."""


@dataclass(eq=False, repr=False)
class ExperimentStreamingServiceMonitorExperimentRequest(betterproto.Message):
    """The ExperimentStreamingServiceMonitorExperimentRequest class."""

    experiment_id: str = betterproto.string_field(1)
    """ID of the experiment to monitor."""

    channel_index: Optional[int] = betterproto.message_field(
        2, wraps=betterproto.TYPE_INT32
    )
    """
    Optional parameter for filtering by specific channel. If the channel index is provided,
     then only that channel will be monitored, but if the channel index is not provided, then
     all channels will be monitored.
    """

    enable_raw_data: bool = betterproto.bool_field(3)
    """
    Value indicating whether the streamed frame data contains raw frames as received from
     the acquisition (when set), which can be either full or partial frames (e.g., in general
     LM cameras produce full frames and LSM and EM detectors produce partial frames/lines).
     Otherwise (when not set) the streamed frame data contains only full frames, which means
     that in the case of partial frames/lines, they would be assembled into full frames.
    """


@dataclass(eq=False, repr=False)
class ExperimentStreamingServiceMonitorExperimentResponse(betterproto.Message):
    """Response object of the method for monitoring an experiment."""

    frame_data: "FrameData" = betterproto.message_field(1)
    """The experiment's frame data."""


class ExperimentServiceStub(betterproto.ServiceStub):
    async def clone(
        self,
        experiment_service_clone_request: "ExperimentServiceCloneRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ExperimentServiceCloneResponse":
        return await self._unary_unary(
            "/zen_api.acquisition.v1beta.ExperimentService/Clone",
            experiment_service_clone_request,
            ExperimentServiceCloneResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def delete(
        self,
        experiment_service_delete_request: "ExperimentServiceDeleteRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ExperimentServiceDeleteResponse":
        return await self._unary_unary(
            "/zen_api.acquisition.v1beta.ExperimentService/Delete",
            experiment_service_delete_request,
            ExperimentServiceDeleteResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def export(
        self,
        experiment_service_export_request: "ExperimentServiceExportRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ExperimentServiceExportResponse":
        return await self._unary_unary(
            "/zen_api.acquisition.v1beta.ExperimentService/Export",
            experiment_service_export_request,
            ExperimentServiceExportResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_available_experiments(
        self,
        experiment_service_get_available_experiments_request: "ExperimentServiceGetAvailableExperimentsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ExperimentServiceGetAvailableExperimentsResponse":
        return await self._unary_unary(
            "/zen_api.acquisition.v1beta.ExperimentService/GetAvailableExperiments",
            experiment_service_get_available_experiments_request,
            ExperimentServiceGetAvailableExperimentsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_image_output_path(
        self,
        experiment_service_get_image_output_path_request: "ExperimentServiceGetImageOutputPathRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ExperimentServiceGetImageOutputPathResponse":
        return await self._unary_unary(
            "/zen_api.acquisition.v1beta.ExperimentService/GetImageOutputPath",
            experiment_service_get_image_output_path_request,
            ExperimentServiceGetImageOutputPathResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_status(
        self,
        experiment_service_get_status_request: "ExperimentServiceGetStatusRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ExperimentServiceGetStatusResponse":
        return await self._unary_unary(
            "/zen_api.acquisition.v1beta.ExperimentService/GetStatus",
            experiment_service_get_status_request,
            ExperimentServiceGetStatusResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def import_(
        self,
        experiment_service_import_request: "ExperimentServiceImportRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ExperimentServiceImportResponse":
        return await self._unary_unary(
            "/zen_api.acquisition.v1beta.ExperimentService/Import",
            experiment_service_import_request,
            ExperimentServiceImportResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def load(
        self,
        experiment_service_load_request: "ExperimentServiceLoadRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ExperimentServiceLoadResponse":
        return await self._unary_unary(
            "/zen_api.acquisition.v1beta.ExperimentService/Load",
            experiment_service_load_request,
            ExperimentServiceLoadResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def register_on_status_changed(
        self,
        experiment_service_register_on_status_changed_request: "ExperimentServiceRegisterOnStatusChangedRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator[ExperimentServiceRegisterOnStatusChangedResponse]:
        async for response in self._unary_stream(
            "/zen_api.acquisition.v1beta.ExperimentService/RegisterOnStatusChanged",
            experiment_service_register_on_status_changed_request,
            ExperimentServiceRegisterOnStatusChangedResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def run_experiment(
        self,
        experiment_service_run_experiment_request: "ExperimentServiceRunExperimentRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ExperimentServiceRunExperimentResponse":
        return await self._unary_unary(
            "/zen_api.acquisition.v1beta.ExperimentService/RunExperiment",
            experiment_service_run_experiment_request,
            ExperimentServiceRunExperimentResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def run_snap(
        self,
        experiment_service_run_snap_request: "ExperimentServiceRunSnapRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ExperimentServiceRunSnapResponse":
        return await self._unary_unary(
            "/zen_api.acquisition.v1beta.ExperimentService/RunSnap",
            experiment_service_run_snap_request,
            ExperimentServiceRunSnapResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def save(
        self,
        experiment_service_save_request: "ExperimentServiceSaveRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ExperimentServiceSaveResponse":
        return await self._unary_unary(
            "/zen_api.acquisition.v1beta.ExperimentService/Save",
            experiment_service_save_request,
            ExperimentServiceSaveResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def start_continuous(
        self,
        experiment_service_start_continuous_request: "ExperimentServiceStartContinuousRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "betterproto_lib_google_protobuf.Empty":
        return await self._unary_unary(
            "/zen_api.acquisition.v1beta.ExperimentService/StartContinuous",
            experiment_service_start_continuous_request,
            betterproto_lib_google_protobuf.Empty,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def start_experiment(
        self,
        experiment_service_start_experiment_request: "ExperimentServiceStartExperimentRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ExperimentServiceStartExperimentResponse":
        return await self._unary_unary(
            "/zen_api.acquisition.v1beta.ExperimentService/StartExperiment",
            experiment_service_start_experiment_request,
            ExperimentServiceStartExperimentResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def start_live(
        self,
        experiment_service_start_live_request: "ExperimentServiceStartLiveRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "betterproto_lib_google_protobuf.Empty":
        return await self._unary_unary(
            "/zen_api.acquisition.v1beta.ExperimentService/StartLive",
            experiment_service_start_live_request,
            betterproto_lib_google_protobuf.Empty,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def start_snap(
        self,
        experiment_service_start_snap_request: "ExperimentServiceStartSnapRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ExperimentServiceStartSnapResponse":
        return await self._unary_unary(
            "/zen_api.acquisition.v1beta.ExperimentService/StartSnap",
            experiment_service_start_snap_request,
            ExperimentServiceStartSnapResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def stop(
        self,
        experiment_service_stop_request: "ExperimentServiceStopRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ExperimentServiceStopResponse":
        return await self._unary_unary(
            "/zen_api.acquisition.v1beta.ExperimentService/Stop",
            experiment_service_stop_request,
            ExperimentServiceStopResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class ExperimentStreamingServiceStub(betterproto.ServiceStub):
    async def monitor_all_experiments(
        self,
        experiment_streaming_service_monitor_all_experiments_request: "ExperimentStreamingServiceMonitorAllExperimentsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator[ExperimentStreamingServiceMonitorAllExperimentsResponse]:
        async for response in self._unary_stream(
            "/zen_api.acquisition.v1beta.ExperimentStreamingService/MonitorAllExperiments",
            experiment_streaming_service_monitor_all_experiments_request,
            ExperimentStreamingServiceMonitorAllExperimentsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def monitor_experiment(
        self,
        experiment_streaming_service_monitor_experiment_request: "ExperimentStreamingServiceMonitorExperimentRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator[ExperimentStreamingServiceMonitorExperimentResponse]:
        async for response in self._unary_stream(
            "/zen_api.acquisition.v1beta.ExperimentStreamingService/MonitorExperiment",
            experiment_streaming_service_monitor_experiment_request,
            ExperimentStreamingServiceMonitorExperimentResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class ExperimentServiceBase(ServiceBase):

    async def clone(
        self, experiment_service_clone_request: "ExperimentServiceCloneRequest"
    ) -> "ExperimentServiceCloneResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete(
        self, experiment_service_delete_request: "ExperimentServiceDeleteRequest"
    ) -> "ExperimentServiceDeleteResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def export(
        self, experiment_service_export_request: "ExperimentServiceExportRequest"
    ) -> "ExperimentServiceExportResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_available_experiments(
        self,
        experiment_service_get_available_experiments_request: "ExperimentServiceGetAvailableExperimentsRequest",
    ) -> "ExperimentServiceGetAvailableExperimentsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_image_output_path(
        self,
        experiment_service_get_image_output_path_request: "ExperimentServiceGetImageOutputPathRequest",
    ) -> "ExperimentServiceGetImageOutputPathResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_status(
        self, experiment_service_get_status_request: "ExperimentServiceGetStatusRequest"
    ) -> "ExperimentServiceGetStatusResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def import_(
        self, experiment_service_import_request: "ExperimentServiceImportRequest"
    ) -> "ExperimentServiceImportResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def load(
        self, experiment_service_load_request: "ExperimentServiceLoadRequest"
    ) -> "ExperimentServiceLoadResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def register_on_status_changed(
        self,
        experiment_service_register_on_status_changed_request: "ExperimentServiceRegisterOnStatusChangedRequest",
    ) -> AsyncIterator[ExperimentServiceRegisterOnStatusChangedResponse]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield ExperimentServiceRegisterOnStatusChangedResponse()

    async def run_experiment(
        self,
        experiment_service_run_experiment_request: "ExperimentServiceRunExperimentRequest",
    ) -> "ExperimentServiceRunExperimentResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def run_snap(
        self, experiment_service_run_snap_request: "ExperimentServiceRunSnapRequest"
    ) -> "ExperimentServiceRunSnapResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def save(
        self, experiment_service_save_request: "ExperimentServiceSaveRequest"
    ) -> "ExperimentServiceSaveResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def start_continuous(
        self,
        experiment_service_start_continuous_request: "ExperimentServiceStartContinuousRequest",
    ) -> "betterproto_lib_google_protobuf.Empty":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def start_experiment(
        self,
        experiment_service_start_experiment_request: "ExperimentServiceStartExperimentRequest",
    ) -> "ExperimentServiceStartExperimentResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def start_live(
        self, experiment_service_start_live_request: "ExperimentServiceStartLiveRequest"
    ) -> "betterproto_lib_google_protobuf.Empty":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def start_snap(
        self, experiment_service_start_snap_request: "ExperimentServiceStartSnapRequest"
    ) -> "ExperimentServiceStartSnapResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def stop(
        self, experiment_service_stop_request: "ExperimentServiceStopRequest"
    ) -> "ExperimentServiceStopResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_clone(
        self,
        stream: "grpclib.server.Stream[ExperimentServiceCloneRequest, ExperimentServiceCloneResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.clone(request)
        await stream.send_message(response)

    async def __rpc_delete(
        self,
        stream: "grpclib.server.Stream[ExperimentServiceDeleteRequest, ExperimentServiceDeleteResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.delete(request)
        await stream.send_message(response)

    async def __rpc_export(
        self,
        stream: "grpclib.server.Stream[ExperimentServiceExportRequest, ExperimentServiceExportResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.export(request)
        await stream.send_message(response)

    async def __rpc_get_available_experiments(
        self,
        stream: "grpclib.server.Stream[ExperimentServiceGetAvailableExperimentsRequest, ExperimentServiceGetAvailableExperimentsResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_available_experiments(request)
        await stream.send_message(response)

    async def __rpc_get_image_output_path(
        self,
        stream: "grpclib.server.Stream[ExperimentServiceGetImageOutputPathRequest, ExperimentServiceGetImageOutputPathResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_image_output_path(request)
        await stream.send_message(response)

    async def __rpc_get_status(
        self,
        stream: "grpclib.server.Stream[ExperimentServiceGetStatusRequest, ExperimentServiceGetStatusResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_status(request)
        await stream.send_message(response)

    async def __rpc_import_(
        self,
        stream: "grpclib.server.Stream[ExperimentServiceImportRequest, ExperimentServiceImportResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.import_(request)
        await stream.send_message(response)

    async def __rpc_load(
        self,
        stream: "grpclib.server.Stream[ExperimentServiceLoadRequest, ExperimentServiceLoadResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.load(request)
        await stream.send_message(response)

    async def __rpc_register_on_status_changed(
        self,
        stream: "grpclib.server.Stream[ExperimentServiceRegisterOnStatusChangedRequest, ExperimentServiceRegisterOnStatusChangedResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.register_on_status_changed,
            stream,
            request,
        )

    async def __rpc_run_experiment(
        self,
        stream: "grpclib.server.Stream[ExperimentServiceRunExperimentRequest, ExperimentServiceRunExperimentResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.run_experiment(request)
        await stream.send_message(response)

    async def __rpc_run_snap(
        self,
        stream: "grpclib.server.Stream[ExperimentServiceRunSnapRequest, ExperimentServiceRunSnapResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.run_snap(request)
        await stream.send_message(response)

    async def __rpc_save(
        self,
        stream: "grpclib.server.Stream[ExperimentServiceSaveRequest, ExperimentServiceSaveResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.save(request)
        await stream.send_message(response)

    async def __rpc_start_continuous(
        self,
        stream: "grpclib.server.Stream[ExperimentServiceStartContinuousRequest, betterproto_lib_google_protobuf.Empty]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.start_continuous(request)
        await stream.send_message(response)

    async def __rpc_start_experiment(
        self,
        stream: "grpclib.server.Stream[ExperimentServiceStartExperimentRequest, ExperimentServiceStartExperimentResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.start_experiment(request)
        await stream.send_message(response)

    async def __rpc_start_live(
        self,
        stream: "grpclib.server.Stream[ExperimentServiceStartLiveRequest, betterproto_lib_google_protobuf.Empty]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.start_live(request)
        await stream.send_message(response)

    async def __rpc_start_snap(
        self,
        stream: "grpclib.server.Stream[ExperimentServiceStartSnapRequest, ExperimentServiceStartSnapResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.start_snap(request)
        await stream.send_message(response)

    async def __rpc_stop(
        self,
        stream: "grpclib.server.Stream[ExperimentServiceStopRequest, ExperimentServiceStopResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.stop(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/zen_api.acquisition.v1beta.ExperimentService/Clone": grpclib.const.Handler(
                self.__rpc_clone,
                grpclib.const.Cardinality.UNARY_UNARY,
                ExperimentServiceCloneRequest,
                ExperimentServiceCloneResponse,
            ),
            "/zen_api.acquisition.v1beta.ExperimentService/Delete": grpclib.const.Handler(
                self.__rpc_delete,
                grpclib.const.Cardinality.UNARY_UNARY,
                ExperimentServiceDeleteRequest,
                ExperimentServiceDeleteResponse,
            ),
            "/zen_api.acquisition.v1beta.ExperimentService/Export": grpclib.const.Handler(
                self.__rpc_export,
                grpclib.const.Cardinality.UNARY_UNARY,
                ExperimentServiceExportRequest,
                ExperimentServiceExportResponse,
            ),
            "/zen_api.acquisition.v1beta.ExperimentService/GetAvailableExperiments": grpclib.const.Handler(
                self.__rpc_get_available_experiments,
                grpclib.const.Cardinality.UNARY_UNARY,
                ExperimentServiceGetAvailableExperimentsRequest,
                ExperimentServiceGetAvailableExperimentsResponse,
            ),
            "/zen_api.acquisition.v1beta.ExperimentService/GetImageOutputPath": grpclib.const.Handler(
                self.__rpc_get_image_output_path,
                grpclib.const.Cardinality.UNARY_UNARY,
                ExperimentServiceGetImageOutputPathRequest,
                ExperimentServiceGetImageOutputPathResponse,
            ),
            "/zen_api.acquisition.v1beta.ExperimentService/GetStatus": grpclib.const.Handler(
                self.__rpc_get_status,
                grpclib.const.Cardinality.UNARY_UNARY,
                ExperimentServiceGetStatusRequest,
                ExperimentServiceGetStatusResponse,
            ),
            "/zen_api.acquisition.v1beta.ExperimentService/Import": grpclib.const.Handler(
                self.__rpc_import_,
                grpclib.const.Cardinality.UNARY_UNARY,
                ExperimentServiceImportRequest,
                ExperimentServiceImportResponse,
            ),
            "/zen_api.acquisition.v1beta.ExperimentService/Load": grpclib.const.Handler(
                self.__rpc_load,
                grpclib.const.Cardinality.UNARY_UNARY,
                ExperimentServiceLoadRequest,
                ExperimentServiceLoadResponse,
            ),
            "/zen_api.acquisition.v1beta.ExperimentService/RegisterOnStatusChanged": grpclib.const.Handler(
                self.__rpc_register_on_status_changed,
                grpclib.const.Cardinality.UNARY_STREAM,
                ExperimentServiceRegisterOnStatusChangedRequest,
                ExperimentServiceRegisterOnStatusChangedResponse,
            ),
            "/zen_api.acquisition.v1beta.ExperimentService/RunExperiment": grpclib.const.Handler(
                self.__rpc_run_experiment,
                grpclib.const.Cardinality.UNARY_UNARY,
                ExperimentServiceRunExperimentRequest,
                ExperimentServiceRunExperimentResponse,
            ),
            "/zen_api.acquisition.v1beta.ExperimentService/RunSnap": grpclib.const.Handler(
                self.__rpc_run_snap,
                grpclib.const.Cardinality.UNARY_UNARY,
                ExperimentServiceRunSnapRequest,
                ExperimentServiceRunSnapResponse,
            ),
            "/zen_api.acquisition.v1beta.ExperimentService/Save": grpclib.const.Handler(
                self.__rpc_save,
                grpclib.const.Cardinality.UNARY_UNARY,
                ExperimentServiceSaveRequest,
                ExperimentServiceSaveResponse,
            ),
            "/zen_api.acquisition.v1beta.ExperimentService/StartContinuous": grpclib.const.Handler(
                self.__rpc_start_continuous,
                grpclib.const.Cardinality.UNARY_UNARY,
                ExperimentServiceStartContinuousRequest,
                betterproto_lib_google_protobuf.Empty,
            ),
            "/zen_api.acquisition.v1beta.ExperimentService/StartExperiment": grpclib.const.Handler(
                self.__rpc_start_experiment,
                grpclib.const.Cardinality.UNARY_UNARY,
                ExperimentServiceStartExperimentRequest,
                ExperimentServiceStartExperimentResponse,
            ),
            "/zen_api.acquisition.v1beta.ExperimentService/StartLive": grpclib.const.Handler(
                self.__rpc_start_live,
                grpclib.const.Cardinality.UNARY_UNARY,
                ExperimentServiceStartLiveRequest,
                betterproto_lib_google_protobuf.Empty,
            ),
            "/zen_api.acquisition.v1beta.ExperimentService/StartSnap": grpclib.const.Handler(
                self.__rpc_start_snap,
                grpclib.const.Cardinality.UNARY_UNARY,
                ExperimentServiceStartSnapRequest,
                ExperimentServiceStartSnapResponse,
            ),
            "/zen_api.acquisition.v1beta.ExperimentService/Stop": grpclib.const.Handler(
                self.__rpc_stop,
                grpclib.const.Cardinality.UNARY_UNARY,
                ExperimentServiceStopRequest,
                ExperimentServiceStopResponse,
            ),
        }


class ExperimentStreamingServiceBase(ServiceBase):

    async def monitor_all_experiments(
        self,
        experiment_streaming_service_monitor_all_experiments_request: "ExperimentStreamingServiceMonitorAllExperimentsRequest",
    ) -> AsyncIterator[ExperimentStreamingServiceMonitorAllExperimentsResponse]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield ExperimentStreamingServiceMonitorAllExperimentsResponse()

    async def monitor_experiment(
        self,
        experiment_streaming_service_monitor_experiment_request: "ExperimentStreamingServiceMonitorExperimentRequest",
    ) -> AsyncIterator[ExperimentStreamingServiceMonitorExperimentResponse]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield ExperimentStreamingServiceMonitorExperimentResponse()

    async def __rpc_monitor_all_experiments(
        self,
        stream: "grpclib.server.Stream[ExperimentStreamingServiceMonitorAllExperimentsRequest, ExperimentStreamingServiceMonitorAllExperimentsResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.monitor_all_experiments,
            stream,
            request,
        )

    async def __rpc_monitor_experiment(
        self,
        stream: "grpclib.server.Stream[ExperimentStreamingServiceMonitorExperimentRequest, ExperimentStreamingServiceMonitorExperimentResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.monitor_experiment,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/zen_api.acquisition.v1beta.ExperimentStreamingService/MonitorAllExperiments": grpclib.const.Handler(
                self.__rpc_monitor_all_experiments,
                grpclib.const.Cardinality.UNARY_STREAM,
                ExperimentStreamingServiceMonitorAllExperimentsRequest,
                ExperimentStreamingServiceMonitorAllExperimentsResponse,
            ),
            "/zen_api.acquisition.v1beta.ExperimentStreamingService/MonitorExperiment": grpclib.const.Handler(
                self.__rpc_monitor_experiment,
                grpclib.const.Cardinality.UNARY_STREAM,
                ExperimentStreamingServiceMonitorExperimentRequest,
                ExperimentStreamingServiceMonitorExperimentResponse,
            ),
        }
